# ü§î Problema de LeetCode: N√∫mero √önico de Ocurrencias

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./1207.UniqueNumberOfOccurrences.md) | [Espa√±ol](./1207.UniqueNumberOfOccurrences-es.md)

## Indice

- [ü§î Problema de LeetCode: N√∫mero √önico de Ocurrencias](#-problema-de-leetcode-n√∫mero-√∫nico-de-ocurrencias)
  - [Indice](#indice)
  - [Intuici√≥n](#intuici√≥n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [üí° Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici√≥n

El problema requiere determinar si el n√∫mero de apariciones de cada elemento √∫nico en una matriz es a su vez √∫nico. Esto significa que tenemos que contar cu√°ntas veces aparece cada n√∫mero y luego verificar que estas frecuencias de recuento no se repiten.
La intuici√≥n clave consiste en seguir un proceso de dos pasos:

1. Contar las apariciones de cada n√∫mero en la matriz de entrada.
2. Comprobar si el n√∫mero de apariciones es √∫nico en todos los elementos contados.

## Enfoque

Para resolver este problema, vamos a utilizar un mapa hash (diccionario) para realizar un seguimiento de la frecuencia de cada n√∫mero en la matriz. El enfoque implica:

1. Crear un objeto/diccionario vac√≠o para almacenar las frecuencias de los n√∫meros
2. Iterar a trav√©s de la matriz e incrementar el recuento para cada n√∫mero
3. Extracci√≥n de los valores de ocurrencia
4. Comparar la longitud de los valores de ocurrencia √∫nica con el n√∫mero total de valores de ocurrencia.

Este enfoque nos permite contar de manera eficiente las ocurrencias y luego validar su unicidad utilizando la funcionalidad de conjunto incorporada.

## Complejidad

- Complejidad temporal: O(n)**

    - Recorremos la matriz una vez para contar las ocurrencias: O(n)
    - Convertimos los valores en un conjunto: O(m), donde m es el n√∫mero de elementos - √∫nicos
    - La complejidad global sigue siendo lineal

- Complejidad espacial: O(m)**

    - Almacenamos un diccionario de recuentos de elementos √∫nicos
    - El espacio requerido es proporcional al n√∫mero de elementos √∫nicos en la matriz

[Ir hacia arriba](#indice)

## üí° Soluciones

- **[Descripci√≥n LeetCode](https://leetcode.com/problems/unique-number-of-occurrences/description/)**
- **[Soluci√≥n Leetcode](https://leetcode.com/problems/unique-number-of-occurrences/solutions/6581506/100-solution-by-danielpaez-dev-nzl9/)**

### JavaScript

- **[Soluci√≥n GitHub](../solutions/JavaScript/1207.UniqueNumberOfOccurrences.js)**

```javascript
var uniqueOccurrences = function (arr) {
    let occurrences = {}
    for (number of arr) {
        occurrences[number] = (occurrences[number] || 0) + 1;
    }
    const values = Object.values(occurrences);
    return new Set(values).size === values.length;
};
```

### Python

- **[Soluci√≥n GitHub](../solutions/Python/1207.UniqueNumberOfOccurrences.py)**

```python
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        occurrences = {}
        for number in arr:
          occurrences[number] = occurrences.get(number, 0) + 1
        values = list(occurrences.values())
        return len(set(values)) == len(values)
```

### TypeScript

- **[Soluci√≥n GitHub](../solutions/TypeScript/1207.UniqueNumberOfOccurrences.ts)**

```typescript
function uniqueOccurrences(arr: number[]): boolean {
    let occurrences: { [key: number]: number } = {};
    for (let number of arr){
        occurrences[number] = (occurrences[number] || 0) +1;
    }
    const values = Object.values(occurrences);
    return new Set(values).size === values.length;
};
```

[Ir hacia arriba](#indice)
