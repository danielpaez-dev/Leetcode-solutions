# 游뱂 Problema de LeetCode: Prefijo com칰n m치s largo

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Go Back](../README.md)

[English](./14.LongestCommonPrefix.md) | [Espa침ol](./14.LongestCommonPrefix-es.md)

## Indice

- [游뱂 Problema de LeetCode: Prefijo com칰n m치s largo](#-problema-de-leetcode-prefijo-com칰n-m치s-largo)
  - [Indice](#indice)
  - [Intuici칩n](#intuici칩n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [游눠 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici칩n

Lo primero que pens칠 fue tomar una palabra para el prefijo e iterar por el array tantas veces como letras tenga esta palabra hasta obtener el prefijo.

## Enfoque

Empezamos comprobando si la matriz de entrada contiene una sola cadena. Si es as칤, podemos devolver directamente esa cadena como prefijo, ya que no hay otras cadenas que comparar.

A continuaci칩n, inicializamos una variable commonPrefix para almacenar el prefijo com칰n m치s largo a medida que recorremos los caracteres de cada cadena. Para cada 칤ndice de caracteres, comparamos los caracteres en esa posici칩n en todas las cadenas. Si alguna cadena tiene un car치cter diferente en ese 칤ndice, devolvemos como resultado el prefijo com칰n actual.

El proceso contin칰a hasta que hayamos comprobado la longitud de la cadena m치s corta de la matriz, asegur치ndonos de no sobrepasar los l칤mites de ninguna cadena.

Si todas las cadenas tienen un car치cter coincidente en cada 칤ndice, acumulamos ese car치cter en el commonPrefix. El resultado es el prefijo com칰n m치s largo encontrado en todas las cadenas.

## Complejidad

- **Complejidad temporal**:
Se trata de una complejidad de tiempo **O(n^2)** porque el c칩digo utiliza 2 fors.

- **Complejidad espacial**:
Este es un c칩digo de complejidad espacial **O(1)** porque s칩lo hay variables temporales sin ninguna estructura de datos compleja.

[Ir hacia arriba](#indice)

## 游눠 Soluciones

- **[Descripci칩n LeetCode](https://leetcode.com/problems/longest-common-prefix/description/)**
- **[Soluci칩n Leetcode](https://leetcode.com/problems/longest-common-prefix/solutions/6536692/on2-solution-by-danielpaez-dev-u157/)**

### JavaScript

- **[Soluci칩n GitHub](../solutions/JavaScript/14.LongestCommonPrefix.js)**

```javascript
var longestCommonPrefix = function (strs) {
    if (strs.length === 1) return strs[0]; // In case there is only one value so it returns the strs directly without passing the for

    let commonPrefix = "";

    for (let i = 0; i < Math.min(...strs.map(str => str.length)); i++) {
        let char = strs[0][i];
        for (let j = 0; j < strs.length; j++) {
            if (strs[j][i] != char) {
                return commonPrefix;
            }
        }
        commonPrefix += char;
    }

    return commonPrefix; // In case there is an array with multiple ""
};
```

### Python

- **[Soluci칩n GitHub](../solutions/Python/14.LongestCommonPrefix.py)**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) == 1:
            return strs[
                0
            ]  # In case there is only one value so it returns the strs directly without passing the for
        commonPrefix = ""

        for i in range(min(len(s) for s in strs)):
            char = strs[0][i]

            for j in range(len(strs)):
                if strs[j][i] != char:
                    return commonPrefix

            commonPrefix += char

        return commonPrefix  # In case there is an array with multiple ""

```

### TypeScript

- **[Soluci칩n GitHub](../solutions/TypeScript/14.LongestCommonPrefix.ts)**

```typescript
function longestCommonPrefix(strs: string[]): string {
  if (strs.length === 1) return strs[0]; // In case there is only one value so it returns the strs directly without passing the for

  let commonPrefix = "";

  for (let i: number = 0; i < Math.min(...strs.map((str) => str.length)); i++) {
    let char: string = strs[0][i];
    for (let j: number = 0; j < strs.length; j++) {
      if (strs[j][i] != char) {
        return commonPrefix;
      }
    }
    commonPrefix += char;
  }

  return commonPrefix; // In case there is an array with multiple ""
}

```

[Ir hacia arriba](#indice)
