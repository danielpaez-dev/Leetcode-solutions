# ðŸ¤” Problema de LeetCode: Sumar Uno

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./66.PlusOne.md) | [EspaÃ±ol](./66.PlusOne-es.md)

## Indice

- [ðŸ¤” Problema de LeetCode: Sumar Uno](#-problema-de-leetcode-sumar-uno)
  - [Indice](#indice)
  - [IntuiciÃ³n](#intuiciÃ³n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [ðŸ’¡ Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## IntuiciÃ³n

El problema nos pide que sumemos uno a un nÃºmero representado como una matriz de dÃ­gitos. La idea clave es manejar la operaciÃ³n de 'llevar' dÃ­gito a dÃ­gito que se produce al sumar uno a un nÃºmero, especialmente cuando se trata de casos como Â«999Â», donde tenemos que llevar varias veces.

## Enfoque

Abordamos este problema simulando el proceso de suma de derecha a izquierda, tal y como harÃ­amos al sumar nÃºmeros a mano:

1. Empezamos por el dÃ­gito mÃ¡s a la derecha (dÃ­gito menos significativo)
2. Suma 1 a este dÃ­gito
3. Si el resultado es menor que 10, hemos terminado - simplemente devuelva la matriz modificada
4. Si el resultado es 10, pon este dÃ­gito a 0 y lleva el 1 al siguiente dÃ­gito continuando el bucle
5. Si hemos pasado por todos los dÃ­gitos y todavÃ­a tenemos un acarreo, tenemos que aÃ±adir un nuevo dÃ­gito inicial de 1

Este enfoque maneja casos como Â«999Â» â†’ Â«1000Â» llevando el 1 hasta el final y aÃ±adiendo un nuevo dÃ­gito inicial.

## Complejidad

- **Complejidad temporal: O(n)**

Donde n es el nÃºmero de dÃ­gitos de la matriz.
En el peor de los casos (por ejemplo, Â«999Â»), necesitamos iterar a travÃ©s de todos los dÃ­gitos.
Sin embargo, el caso medio es O(1), ya que normalmente sÃ³lo modificamos los Ãºltimos dÃ­gitos.

- **Complejidad espacial: O(1)**

Para el caso tÃ­pico, ya que modificamos la matriz de entrada in situ.
En el peor de los casos (todos los 9), creamos una nueva matriz con un dÃ­gito extra, que es O(n).

[Ir hacia arriba](#indice)

## ðŸ’¡ Soluciones

- **[DescripciÃ³n LeetCode](https://leetcode.com/problems/plus-one/description/)**
- **[SoluciÃ³n Leetcode](https://leetcode.com/problems/plus-one/solutions/6557237/solution/)**

### JavaScript

- **[SoluciÃ³n GitHub](../solutions/JavaScript/66.PlusOne.js)**

```javascript
var plusOne = function (digits) {
    const length = digits.length - 1;

    for (let i = length; i >= 0; i--) {
        digits[i] += 1;
        if (digits[i] < 10) return digits;
        digits[i] = 0;
    }

    digits.unshift(1);
    return digits;
};
```

### Python

- **[SoluciÃ³n GitHub](../solutions/Python/66.PlusOne.py)**

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:

        length: int = len(digits)

        for i in reversed(range(length)):
            digits[i] += 1
            if digits[i] < 10:
                return digits
            digits[i] = 0

        return [1] + digits
```

### TypeScript

- **[SoluciÃ³n GitHub](../solutions/TypeScript/66.PlusOne.ts)**

```typescript
function plusOne(digits: number[]): number[] {
    const length: number = digits.length - 1;

    for(let i: number = length; i >= 0; i--){
        digits[i] += 1;
        if(digits[i] < 10) return digits;
        digits[i] = 0;
    }

    digits.unshift(1);
    return digits;
};
```

[Ir hacia arriba](#indice)
