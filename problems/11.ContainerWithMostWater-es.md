# 游뱂 Problema de LeetCode: Contenedor Con M치s Agua

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./11.ContainerWithMostWater.md) | [Espa침ol](./11.ContainerWithMostWater-es.md)

## Indice

- [游뱂 Problema de LeetCode: Contenedor Con M치s Agua](#-problema-de-leetcode-contenedor-con-m치s-agua)
  - [Indice](#indice)
  - [Intuici칩n](#intuici칩n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [游눠 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici칩n

El problema nos pide encontrar la cantidad m치xima de agua que puede estar contenida entre dos l칤neas verticales de una gr치fica. Lo primero que se me ocurre es que el 치rea de agua contenida entre dos l칤neas cualesquiera viene determinada por:

- La anchura entre las l칤neas (distancia entre 칤ndices)
- La altura de la l칤nea m치s corta (el agua s칩lo puede subir tanto como la l칤nea m치s corta)

Esto sugiere una f칩rmula directa: 치rea = anchura 칑 altura m칤nima. Similar al **치rea de un rect치ngulo**.

## Enfoque

En lugar de comprobar todos los pares posibles (que ser칤a O(n)), podemos utilizar un enfoque de dos puntos para que podamos minimizar el c치lculo obteniendo el 치rea m치xima de los puntos m치s altos de izquierda a derecha. Esto se hace as칤

1. Empezar con punteros en los extremos del array (anchura m치xima)
2. Calcular el 치rea bas치ndote en los punteros actuales
3. Mover el puntero con la altura m치s corta hacia el interior (ya que mover el m치s alto s칩lo disminuir칤a el 치rea)
4. Continuar hasta que los punteros se encuentren

Este m칠todo funciona porque:

- Empieza con la anchura m치xima nos da un 치rea m치xima potencial
- Mover hacia dentro disminuye la anchura, por lo que necesitamos encontrar l칤neas m치s altas para compensar
- Mover la l칤nea m치s corta hacia dentro es 칩ptimo porque:

    - La l칤nea m치s corta actual limita nuestra 치rea actual.
    - Mantenerla s칩lo conducir칤a a 치reas m치s peque침as a medida que la anchura disminuye.
    - Moverla nos da la oportunidad de encontrar una l칤nea m치s alta que podr칤a aumentar el 치rea

## Complejidad

- **Complejidad temporal: O(n)**

    - Procesamos cada elemento como m치ximo una vez, haciendo una 칰nica pasada por el array
    - Cada iteraci칩n requiere operaciones en tiempo constante
    - N칰mero m치ximo de iteraciones = longitud de la matriz - 1

- **Complejidad espacial: O(1)**

    - S칩lo utilizamos un n칰mero fijo de variables, independientemente del tama침o de la entrada
    - No se necesitan estructuras de datos adicionales

## 游눠 Soluciones

- **[Descripci칩n LeetCode](https://leetcode.com/problems/container-with-most-water/description/)**
- **[Soluci칩n Leetcode](https://leetcode.com/problems/container-with-most-water/solutions/6603153/beats-75-python-js-and-ts-by-danielpaez-3pwi2/)**

### JavaScript

- **[Soluci칩n GitHub](../solutions/JavaScript/11.ContainerWithMostWater.js)**

```javascript
var maxArea = function (height) {
    let maxArea = 0;
    let left = 0;
    let right = height.length - 1;

    while (left < right) {
        let area = (right - left) * Math.min(height[left], height[right]);
        maxArea = Math.max(maxArea, area);

        height[left] < height[right] ? left++ : right--;
    }

    return maxArea;
};
```

### Python

- **[Soluci칩n GitHub](../solutions/Python/11.ContainerWithMostWater.py)**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        max_area: int = 0
        left: int = 0
        right: int = len(height) - 1

        while left < right:
            area: int = (right - left) * min(height[left], height[right])
            max_area = max(max_area, area)

            if height[left] < height[right]:
                left += 1
            else:
                right -= 1

        return max_area
```

### TypeScript

- **[Soluci칩n GitHub](../solutions/TypeScript/11.ContainerWithMostWater.ts)**

```typescript
function maxArea(height: number[]): number {
    let maxArea: number = 0;
    let left: number = 0;
    let right: number = height.length - 1;

    while (left < right) {
        let area: number = (right - left) * Math.min(height[left], height[right]);
        maxArea = Math.max(maxArea, area);

        height[left] < height[right] ? left++ : right--;
    }

    return maxArea;
};
```

[Back to Top](#index)
