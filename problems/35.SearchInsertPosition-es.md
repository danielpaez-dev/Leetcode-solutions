#  LeetCode Problema: Buscar posici贸n de inserci贸n

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./28.FindTheIndexOfTheFirstOccurrenceInAString.md) | [Espa帽ol](./28.FindTheIndexOfTheFirstOccurrenceInAString-es.md)

## Indice

- [ LeetCode Problema: Buscar posici贸n de inserci贸n](#-leetcode-problema-buscar-posici贸n-de-inserci贸n)
  - [Indice](#indice)
  - [Intuici贸n](#intuici贸n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [Nota](#nota)
  - [ Solutions](#-solutions)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici贸n

Lo que tenemos que hacer est谩 claro. Buscar la posici贸n correcta de un elemento en un array ordenado, o la posici贸n donde deber铆a insertarse si no est谩 presente. Como tenemos que hacerlo optimizado **la b煤squeda binaria** encaja perfecto para el problema.

## Enfoque

Implementamos una b煤squeda binaria est谩ndar que divide repetidamente el espacio de b煤squeda por la mitad. La clave es devolver el 铆ndice de la izquierda cuando no se encuentra el elemento, ya que representa exactamente d贸nde se debe insertar el elemento para mantener el array ordenado.
El algoritmo funciona as铆

1. Inicializa los punteros izquierdo y derecho en los extremos del array
2. En cada iteraci贸n, calcular el punto medio
3. Si encontramos el elemento, devolver su 铆ndice
4. Si el elemento medio es menor que el objetivo, descartar la mitad izquierda
5. Si es mayor, descarta la mitad derecha
6. Al final, si no encontramos el elemento, la izquierda indicar谩 la posici贸n de inserci贸n correcta

## Complejidad

- **Complejidad temporal: O(log n)**

Cada iteraci贸n reduce el espacio de b煤squeda a la mitad

- **Complejidad espacial: O(1)**

S贸lo utilizamos variables auxiliares de tama帽o constante

## Nota

Podemos optimizar a煤n m谩s el c贸digo si, conociendo la longitud del array, elegimos entre este m茅todo de b煤squeda binaria o el de fuerza bruta ya que la b煤squeda binaria es ligeramente peor en el escenario en que el array sea muy peque帽o.

[Ir hacia arriba](#indice)

##  Solutions

- **[Description LeetCode](https://leetcode.com/problems/search-insert-position/description/)**
- **[Solution Leetcode](https://leetcode.com/problems/search-insert-position/solutions/6557115/binary-search-solution-by-danielpaez-dev-c25g/)**

### JavaScript

- **[Solution GitHub](../solutions/JavaScript/35.SearchInsertPosition.js)**

```javascript
var searchInsert = function (nums, target) {
    let left = 0;
    let right = nums.length - 1;
    mid = 0;

    while (left <= right) {
        mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left;
};
```

### Python

- **[Solution GitHub](../solutions/Python/35.SearchInsertPosition.py)**

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left: int = 0
        right: int = len(nums) - 1

        while(left <= right):
            mid = (left + right) // 2

            if nums[mid] == target:
                return mid
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return left
```

### TypeScript

- **[Solution GitHub](../solutions/TypeScript/35.SearchInsertPosition.ts)**

```typescript
function searchInsert(nums: number[], target: number): number {
    let left: number = 0;
    let right: number = nums.length - 1;
    let mid: number = 0;

    while (left <= right) {
        mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left;
};
```

[Ir hacia arriba](#indice)
