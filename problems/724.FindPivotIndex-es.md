#  Problema de LeetCode: Encontrar el ndice del Pivote

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./724.FindPivotIndex.md) | [Espa帽ol](./724.FindPivotIndex-es.md)

## Indice

- [ Problema de LeetCode: Encontrar el ndice del Pivote](#-problema-de-leetcode-encontrar-el-铆ndice-del-pivote)
  - [Indice](#indice)
  - [Intuici贸n](#intuici贸n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [ Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici贸n

El 铆ndice pivote es el 铆ndice donde la suma de elementos a la izquierda es igual a la suma de elementos a la derecha.
Mi primera idea fue utilizar dos punteros pero no estaba funcionando.
As铆 que me di cuenta que si precalculamos la suma total del array y en cada posici贸n, podemos calcular la suma a la derecha restando el elemento actual y la suma a la izquierda de la suma total, eliminando la necesidad de c谩lculos repetidos podemos llegar a la soluci贸n del 铆ndice pivote.

## Enfoque

1. Calcular la suma total de todos los elementos de la matriz (la suma derecha inicial)
2. Inicializar la suma izquierda a cero
3. Recorrer cada posici贸n de la matriz:

    - Restar el elemento actual de la suma derecha
    - Comprobar si la suma izquierda es igual a la suma derecha
    - Si es igual, devuelve el 铆ndice actual como pivote
    - En caso contrario, a帽adir el elemento actual a la suma izquierda y continuar

4. Si no se encuentra ning煤n 铆ndice pivote, devuelve -1

## Complejidad

- **Complejidad temporal: O(n)**

    - Recorremos la matriz dos veces: una para calcular la suma total y otra para encontrar el 铆ndice pivote.
    - Ambas operaciones son lineales con respecto a la longitud de la matriz

- **Complejidad espacial: O(1)**

    - S贸lo utilizamos una cantidad constante de espacio adicional, independientemente del tama帽o de la entrada.
    - S贸lo mantenemos dos variables (sumaizquierda y sumaderecha) durante todo el algoritmo

[Volver Arriba](#indice)

##  Soluciones

- **[Descripci贸n LeetCode](https://leetcode.com/problems/find-pivot-index/description/)**
- **[Soluci贸n Leetcode](https://leetcode.com/problems/find-pivot-index/solutions/6649854/my-solution-by-danielpaez-dev-cjcp/)**

### JavaScript

- **[Soluci贸n GitHub](../solutions/JavaScript/724.FindPivotIndex.js)**

```javascript
var pivotIndex = function (nums) {
    let leftSum = 0, rightSum = 0;

    for (let num of nums) {
        rightSum += num
    }

    for (let i = 0; i <= nums.length - 1; i++) {
        rightSum -= nums[i]
        if (leftSum == rightSum) return i
        leftSum += nums[i]
    }

    return -1;
};
```

### Python

- **[Soluci贸n GitHub](../solutions/Python/724.FindPivotIndex.py)**

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        left_sum, right_sum = 0, sum(nums)

        for i, num in enumerate(nums):
            right_sum -= num
            if left_sum == right_sum:
                return i
            left_sum += num

        return -1
```

### TypeScript

- **[Soluci贸n GitHub](../solutions/TypeScript/724.FindPivotIndex.ts)**

```typescript
function pivotIndex(nums: number[]): number {
    let leftSum = 0, rightSum = 0;

    for (let num of nums) {
        rightSum += num;
    }

    for (let i = 0; i < nums.length; i++) {
        rightSum -= nums[i];
        if (leftSum == rightSum) return i
        leftSum += nums[i];
    }

    return -1
};
```

[Volver Arriba](#indice)
