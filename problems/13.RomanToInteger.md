# ðŸ¤” LeetCode Problem: Remove Duplicates from Sorted Array
![Difficulty: Easy](https://img.shields.io/badge/Difficulty-Easy-brightgreen)
![Topic: Arrays](https://img.shields.io/badge/Topic-Arrays-blue)
![Topic: Hash Table](https://img.shields.io/badge/Topic-Hash_Table-blue)
![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Go Back](../README.md)

[English](./26.RemoveDuplicatesFromSortedArray.md) | [EspaÃ±ol](./26.RemoveDuplicatesFromSortedArray-es.md)

## Index
- [ðŸ¤” LeetCode Problem: Remove Duplicates from Sorted Array](#-leetcode-problem-remove-duplicates-from-sorted-array)
  - [Index](#index)
  - [ðŸ“– Problem Description](#-problem-description)
    - [Examples](#examples)
      - [Example 1:](#example-1)
      - [Example 2:](#example-2)
    - [Constraints:](#constraints)
  - [Back to Top](#back-to-top)
  - [ðŸ’¡ Solutions](#-solutions)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## ðŸ“– Problem Description

[Two Sum - LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates in-place such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return the number of unique elements in `nums`.

Consider the number of unique elements of `nums` to be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first k elements of nums contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.

- Return `k`.

**Custom Judge**:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be **accepted**.

### Examples

#### Example 1:
**Input**: nums = [1,1,2]<br>
**Output**: 2, nums = [1,2,_]<br>
**Explanation**: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).


#### Example 2:
**Input:** nums = [0,0,1,1,1,2,2,3,3,4]<br>
**Output:** 5, nums = [0,1,2,3,4,_,_,_,_,_]<br>
**Explanation**: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).


### Constraints:

- $$1 \leq nums.length \leq 3 * 10^4$$
- $$-100 \leq nums[i] \leq 100$$
- `nums` is sorted in **non-decreasing** order.

[Back to Top](#index)
---

## ðŸ’¡ Solutions

- **[Solution Leetcode](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/6532218/two-pointers-solution-by-danielpaez-dev-vweu/)**


### JavaScript
- **[Solution GitHub](../solutions/JavaScript/13.RomanToInteger.js)**
```javascript
var romanToInt = function (s) {
    let result = 0;

    for (let i = 0; i < s.length; i++) {
        if (
            (s[i] === "I" && ["V", "X"].includes(s[i + 1])) ||
            (s[i] === "X" && ["L", "C"].includes(s[i + 1])) ||
            (s[i] === "C" && ["D", "M"].includes(s[i + 1]))
        ) {
            result -= getRomanValue(s[i]);
        } else {
            result += getRomanValue(s[i]);
        }
    }

    return result;
};

function getRomanValue(char) {
    switch (char) {
        case "I": return 1;
        case "V": return 5;
        case "X": return 10;
        case "L": return 50;
        case "C": return 100;
        case "D": return 500;
        case "M": return 1000;
        default: return 0;
    }
}
```

### Python
- **[Solution GitHub](../solutions/Python/13.RomanToInteger.py)**
```python
class Solution:
    def romanToInt(self, s: str) -> int:
        result = 0
        length = len(s)

        for i in range(length):
            if i < length - 1 and (
                (s[i] == "I" and s[i + 1] in ["V", "X"])
                or (s[i] == "X" and s[i + 1] in ["L", "C"])
                or (s[i] == "C" and s[i + 1] in ["D", "M"])
            ):
                result -= self.roman_switch(s[i])
            else:
                result += self.roman_switch(s[i])

        return result

    def roman_switch(self, char: str) -> int:
        switch = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}
        return switch.get(char, 0)  # 0 if the character is not in the dictionary

```

### TypeScript
- **[Solution GitHub](../solutions/TypeScript/13.RomanToInteger.ts)**
```typescript
function romanToInt(s: string): number {
  let result: number = 0;

  for (let i: number = 0; i < s.length; i++) {
    if (
      (s[i] === "I" && ["V", "X"].includes(s[i + 1])) ||
      (s[i] === "X" && ["L", "C"].includes(s[i + 1])) ||
      (s[i] === "C" && ["D", "M"].includes(s[i + 1]))
    ) {
      result -= getRomanValue(s[i]);
    } else {
      result += getRomanValue(s[i]);
    }
  }

  return result;
}

function getRomanValue(char) {
  switch (char) {
    case "I":
      return 1;
    case "V":
      return 5;
    case "X":
      return 10;
    case "L":
      return 50;
    case "C":
      return 100;
    case "D":
      return 500;
    case "M":
      return 1000;
    default:
      return 0;
  }
}

```
[Back to Top](#index)

You can explore other problems done [here](https://github.com/Daniel-Paez-Rojas/leetcode.git).

---


[Back to Top](#index)