# 游뱂 Problema de LeetCode: Adivinar N칰mero Superior O Inferior

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./374.GuessNumberHigherOrLower.md) | [Espa침ol](./374.GuessNumberHigherOrLower-es.md)

## Indice

- [游뱂 Problema de LeetCode: Adivinar N칰mero Superior O Inferior](#-problema-de-leetcode-adivinar-n칰mero-superior-o-inferior)
  - [Indice](#indice)
  - [Intuici칩n](#intuici칩n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [游눠 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici칩n

La **b칰squeda binaria** es el enfoque perfecto para este problema, ya que estamos tratando de encontrar de manera eficiente un n칰mero espec칤fico dentro de un rango, y obtenemos informaci칩n en cada conjetura que nos dice si nuestra conjetura es demasiado alta, demasiado baja, o correcta.

## Enfoque

1. Implementar un algoritmo de b칰squeda binaria para encontrar el n칰mero objetivo
2. Inicializar el rango de b칰squeda de 1 a n
3. En cada iteraci칩n

    - Calcular el valor medio del rango actual
    - Llama a la funci칩n proporcionada por la API guess(num):

        - Si devuelve -1, nuestra estimaci칩n es demasiado alta, por lo que la b칰squeda en la mitad inferior
        - Si devuelve 1, nuestra estimaci칩n es demasiado baja, por lo que debemos buscar en la mitad superior.
        - Si devuelve 0, hemos encontrado el n칰mero objetivo, devu칠lvelo

4. Contin칰a estrechando el rango de b칰squeda hasta que encontremos el objetivo

## Complejidad

- **Complejidad temporal: O(log n)**

    La b칰squeda binaria reduce a la mitad el rango de b칰squeda en cada iteraci칩n, lo que lleva a una complejidad temporal logar칤tmica

- **Complejidad espacial: O(1)**

    S칩lo utilizamos una cantidad constante de espacio adicional independientemente del tama침o de la entrada (unas pocas variables para rastrear el rango de b칰squeda).

[Ir hacia arriba](#indice)

## 游눠 Soluciones

- **[Descripci칩n LeetCode](https://leetcode.com/problems/guess-number-higher-or-lower/description/)**
- **[Soluci칩n Leetcode](https://leetcode.com/problems/guess-number-higher-or-lower/solutions/6570416/my-solution-by-danielpaez-dev-aplw/)**

### JavaScript

- **[Soluci칩n GitHub](../solutions/JavaScript/374.GuessNumberHigherOrLower.js)**

```javascript
var guessNumber = function (n) {
    let left = 1;
    let right = n;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        let pick = guess(mid);
        if (pick === -1) {
            right = mid - 1;
        } else if (pick === 1) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
};
```

### Python

- **[Soluci칩n GitHub](../solutions/Python/374.GuessNumberHigherOrLower.py)**

```python
class Solution:
    def guessNumber(self, n: int) -> int:
        left: int = 1
        end: int = n

        while left <= end:
            mid: int = (left + end) // 2
            pick = guess(mid)
            if pick == -1:
                end = mid - 1
            elif pick == 1:
                left = mid + 1
            else:
                return mid

```

### TypeScript

- **[Soluci칩n GitHub](../solutions/TypeScript/374.GuessNumberHigherOrLower.ts)**

```typescript
function guessNumber(n: number): number {
    let left: number = 1;
    let right: number = n;
    while (left <= right) {
        let mid: number = Math.floor((left + right) / 2);
        let pick: number = guess(mid);
        if (pick === -1) {
           right = mid - 1;
        } else if(pick === 1){
            left = mid + 1;
        } else {
            return mid;
        }
    }
};
```

[Ir hacia arriba](#indice)
