# ğŸ¤” Problema de LeetCode: Dos Sumas

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Ir atrÃ¡s](../README-es.md)

[English](./1.TwoSum.md) | [EspaÃ±ol](./1.TwoSum-es.md)

## Indice

- ğŸ¤” [LeetCode Problema: Dos Sumas](#-problema-de-leetcode:-dos-sumas)
  - [ğŸ“ Ãndice](#-indice)
  - [ğŸ“– DescripciÃ³n del problema](#-descripcion-del-problema)
    - [Ejemplos](#ejemplos)
      - [Ejemplo 1:](#ejemplo-1)
      - [Ejemplo 2:](#ejemplo-2)
      - [Ejemplo 3:](#ejemplo-3)
    - [Restricciones:](#restricciones)
  - [ğŸ’¡ Soluciones](#-soluciones)
    - [JavaScript](#javascript)
  - [âœï¸ Notas](#ï¸-notas)

## IntuiciÃ³n

Mi enfoque inicial era la fuerza bruta, que tiene una complejidad de tiempo de O(nÂ²), ya que implica la comparaciÃ³n de cada nÃºmero con todos los demÃ¡s nÃºmeros de la matriz. Era la soluciÃ³n mÃ¡s fÃ¡cil, pero resultÃ³ ser ineficiente como las mÃ©tricas de otras personas mostraron, por lo que me dirigÃ­ a una soluciÃ³n con al menos una complejidad de tiempo de O(n).

## Enfoque

El enfoque itera a travÃ©s de la matriz nums sÃ³lo una vez. Para cada nÃºmero nums[i], el algoritmo calcula su complemento (el valor necesario para alcanzar el objetivo: objetivo - nums[i]). A continuaciÃ³n, comprueba si este complemento ya existe como clave en el objeto numMap (que actÃºa como una tabla hash). Si se encuentra el complemento, el algoritmo devuelve una matriz que contiene el Ã­ndice del complemento (almacenado en numMap) y el Ã­ndice actual i. Si no se encuentra el complemento, el nÃºmero actual nums[i] y su Ã­ndice i se aÃ±aden a numMap para futuras bÃºsquedas. De este modo se evitan los bucles anidados y se consigue una complejidad temporal lineal.

## Complejidad

- **Complejidad temporal**: O(n)
El algoritmo itera a travÃ©s de la matriz nums sÃ³lo una vez. Las operaciones dentro del bucle (calcular el complemento, comprobar numMap, y aÃ±adir a numMap) toman un tiempo medio constante. Por tanto, la complejidad temporal total es O(n).

- Complejidad espacial**: O(n)
En el peor de los casos (cuando no hay dos nÃºmeros que sumen el objetivo hasta el final de la matriz o si no existe soluciÃ³n), el objeto numMap podrÃ­a almacenar todos los n elementos de la matriz nums. Por lo tanto, la complejidad espacial es O(n). Aunque esto utiliza mÃ¡s espacio que la fuerza bruta.

[Volver al principio](#indice)

## ğŸ’¡ Soluciones

- **[DescripciÃ³n LeetCode](https://leetcode.com/problems/two-sum/description/)**
- **[SoluciÃ³n Leetcode](https://leetcode.com/problems/two-sum/solutions/6278845/map-solution/)**


### JavaScript

- **[Map Solution GitHub](../solutions/JavaScript/1.TwoSum.js)**

```javascript
/*
 * The equation is: a + b = x; => a = current number , b = complement, x = target.
 * - i is the index of the current number (a).
 * - nums[i] is the current number (a).
 * The idea is to find a number (complement b) whose sum with nums[i] equals the target.
 */

let twoSum = function (nums, target) {
  const numMap = {};

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (numMap.hasOwnProperty(complement)) {
      return [numMap[complement], i];
    }
    numMap[nums[i]] = i;
  }

  return []; // In case there is no solution
};
```

### Python

- **[Map Solution GitHub](../solutions/Python/1.TwoSum.py)**

```python
class Solution:
    """
    The equation is: a + b = x; => a = current number , b = complement, x = target.
    - i is the index of the current number (a).
    - nums[i] is the current number (a).
    The idea is to find a number (complement b) whose sum with nums[i] equals the target.
    """

    def twoSum(self, nums: list[int], target: int) -> list[int]:
        num_map = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                return [num_map[complement], i]
            num_map[num] = i
        return []  # In case there's no solution
```

### TypeScript

- **[Map Solution GitHub](../solutions/TypeScript/1.TwoSum.ts)**

```typescript
/*
 * The equation is: a + b = x; => a = current number , b = complement, x = target.
 * - i is the index of the current number (a).
 * - nums[i] is the current number (a).
 * The idea is to find a number (complement b) whose sum with nums[i] equals the target.
 */

function twoSum(nums: number[], target: number): number[] {
  const numMap: { [key: number]: number } = {};

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (numMap.hasOwnProperty(complement)) {
      return [numMap[complement], i];
    }
    numMap[nums[i]] = i;
  }

  return [];
}
```

Puede explorar otros problemas realizados [aquÃ­](https://github.com/Daniel-Paez-Rojas/leetcode.git).

[Volver al principio](#indice)
