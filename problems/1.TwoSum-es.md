# 🤔 Problema de LeetCode: Dos Sumas
![Dificultad: Fácil](https://img.shields.io/badge/Difficulty-Easy-brightgreen)
![Tema: Matrices](https://img.shields.io/badge/Topic-Arrays-blue)
![Tema: Tabla Hash](https://img.shields.io/badge/Topic-Hash_Table-blue)
![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Ir atrás](../README-es.md)

[English](./README.md) | [Español](./README-es.md)

## 📝 Índice
- 🤔 [LeetCode Problema: Dos Sumas](#-problema-de-leetcode:-dos-sumas)
  - [📝 Índice](#-indice)
  - [📖 Descripción del problema](#-descripcion-del-problema)
    - [Ejemplos](#ejemplos)
      - [Ejemplo 1:](#ejemplo-1)
      - [Ejemplo 2:](#ejemplo-2)
      - [Ejemplo 3:](#ejemplo-3)
    - [Restricciones:](#restricciones)
  - [💡 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
  - [✏️ Notas](#️-notas)

## 📖 Descripción del Problema

[Dos Suma - LeetCode](https://leetcode.com/problems/two-sum/description/)

Dado un array de enteros `nums` y un entero `target`, devolver los índices de los dos números tales que sumen el `target`.

Puede suponer que cada entrada tendría **exactamente una **solución****, y no puede utilizar el mismo elemento dos veces.

Puede devolver la respuesta en cualquier orden.

### Ejemplos

#### Ejemplo 1:
**Entrada**: números = [2,7,11,15], objetivo = 9
**Salida**: [0,1]
**Explicación**: Como núm[0] + núm[1] == 9, devolvemos [0, 1].


#### Ejemplo 2:
**Entrada:**
números = [3,2,4], objetivo = 6
**Salida:**
[1,2]


#### Ejemplo 3:
**Entrada:**
números = [3,3], objetivo = 6
**Salida:**
[0,1]


### Restricciones:

- $$2 \leq nums.length \leq 10^4$$
- $$-10^9 \leq números[i] \leq 10^9$$
- $$-10^9 \leq objetivo \leq 10^9$$
- **Sólo existe una respuesta válida.**

[Volver al principio](#-indice)
---

## 💡 Soluciones

- **[Solución Leetcode](https://leetcode.com/problems/two-sum/solutions/6278845/map-solution/)**


### JavaScript
- **[Map Solution GitHub](../solutions/JavaScript/1.TwoSum/TwoSum.js)**
```javascript
/*
 * The equation is: a + b = x; => a = current number , b = complement, x = target.
 * - i is the index of the current number (a).
 * - nums[i] is the current number (a).
 * The idea is to find a number (complement b) whose sum with nums[i] equals the target.
 */

let twoSum = function (nums, target) {
  const numMap = {};

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (numMap.hasOwnProperty(complement)) {
      return [numMap[complement], i];
    }
    numMap[nums[i]] = i;
  }

  return []; // In case there is no solution
};
```

### Python
- **[Map Solution GitHub](../solutions/Python/1.TwoSum/TwoSum.py)**
```python
class Solution:
    """
    The equation is: a + b = x; => a = current number , b = complement, x = target.
    - i is the index of the current number (a).
    - nums[i] is the current number (a).
    The idea is to find a number (complement b) whose sum with nums[i] equals the target.
    """

    def twoSum(self, nums: list[int], target: int) -> list[int]:
        num_map = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                return [num_map[complement], i]
            num_map[num] = i
        return []  # In case there's no solution
```

### TypeScript
- **[Map Solution GitHub](../solutions/TypeScript/1.TwoSum/TwoSum.ts)**
```typescript
/*
 * The equation is: a + b = x; => a = current number , b = complement, x = target.
 * - i is the index of the current number (a).
 * - nums[i] is the current number (a).
 * The idea is to find a number (complement b) whose sum with nums[i] equals the target.
 */

function twoSum(nums: number[], target: number): number[] {
  const numMap: { [key: number]: number } = {};

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (numMap.hasOwnProperty(complement)) {
      return [numMap[complement], i];
    }
    numMap[nums[i]] = i;
  }

  return [];
}
```

[Volver al principio](#-indice)

Puede explorar otros problemas realizados aquí [aquí](https://github.com/Daniel-Paez-Rojas/leetcode.git).

---

## ✏️ Notas

Mi primer problema Leetcode hecho.

[Volver al principio](#-indice)