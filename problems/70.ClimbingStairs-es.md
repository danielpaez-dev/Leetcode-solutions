# ü§î Problema de Leetcode: Subir Escaleras

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Go Back](../README.md)

[English](./70.ClimbingStairs.md) | [Espa√±ol](./70.ClimbingStairs-es.md)

## Indice

- [ü§î Problema de Leetcode: Subir Escaleras](#-problema-de-leetcode-subir-escaleras)
  - [Indice](#indice)
  - [Intuici√≥n](#intuici√≥n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [üí° Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici√≥n

Lo primero que hice fue comprobar cu√°ntos pasos ser√≠an posibles con n√∫meros m√°s altos para ver si hab√≠a alg√∫n patr√≥n contabizable en esta f√≥rmula s√≥lo con l√°piz y papel. Utilic√© el 5 y el 6 y observ√© que el resultado era igual a la **secuencia de Fibonaci**, por lo que 5 era igual a 8 y 6 a 13.
Esto se debe a que
$f(n) = f(n-1) + f(n-2)$
y esta es la definici√≥n de la f√≥rmula de Fibonacci.
Puede ser dif√≠cil de ver debido a la descripci√≥n del problema, pero con s√≥lo comprobar en el papel qu√© resultados pueden tener otros n√∫meros te puedes dar cuenta de esto si sabes lo que es la secuencia de Fibonacci.

## Enfoque

Esto fue f√°cil de programar porque fue una de las primeras cosas que program√© cuando empec√© a aprender a programar.

As√≠ que,

1. En primer lugar, manejar los casos base: `if n ‚â§ 2`, entonces el n√∫mero de formas es igual a `n`.
2. Para valores mayores de `n`, utilice un enfoque iterativo para calcular los n√∫meros de Fibonacci:

    - Inicialice dos variables para representar el n√∫mero de formas de alcanzar el paso 1 (`step1 = 1`) y el paso 2 (`step2 = 2`).
    - Iterar de 3 a `n`, calculando cada valor subsiguiente utilizando la f√≥rmula de Fibonacci.
    - En cada paso, actualiza `step1` y `step2` para almacenar los dos n√∫meros Fibonacci anteriores.

## Complejidad

- **Complejidad temporal**:
**O(n)** S√≥lo necesitamos un √∫nico bucle de 3 a n para calcular la respuesta. Cada iteraci√≥n implica un n√∫mero constante de operaciones. En el mejor de los casos ser√≠a O(1) si `n ‚â§ 2`.

- **Complejidad espacial**:
**O(1)** S√≥lo necesitamos tres variables (`step1`, `step2`, y `temp`) independientemente del tama√±o de la entrada, por lo que la complejidad espacial es constante.

[Ir hacia arriba](#indice)

## üí° Soluciones

- **[Descrici√≥n LeetCode](https://leetcode.com/problems/climbing-stairs/description/)**
- **[Soluci√≥n Leetcode](https://leetcode.com/problems/climbing-stairs/solutions/6549145/fibonacci-stairs-by-danielpaez-dev-ewik/)**

### JavaScript

- **[Soluci√≥n GitHub](../solutions/JavaScript/70.ClimbingStairs.js)**

```javascript
var mySqrt = function (x) {
    if (x < 2) return x;

    let start = 1;
    let end = Math.floor(x / 2);
    let solution = 0;

    while (start <= end) {
        let mid = Math.floor((start + end) / 2);

        if (mid * mid === x) {
            return mid;
        }
        else if (mid * mid < x) {
            solution = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }

    }
    return solution;
};
```

### Python

- **[Soluci√≥n GitHub](../solutions/Python/70.ClimbingStairs.py)**

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x

        start = 1
        end = math.floor(x // 2)
        solution = 0

        while start <= end:
            mid = (start + end) // 2

            if mid * mid == x:
                return mid

            elif mid * mid < x:
                solution = mid
                start = mid + 1
            else:
                end = mid - 1

        return solution
```

### TypeScript

- **[Soluci√≥n GitHub](../solutions/TypeScript/70.ClimbingStairs.ts)**

```typescript
function mySqrt(x: number): number {
    if (x < 2) return x;

    let start: number = 1;
    let end: number = Math.floor(x / 2);
    let solution: number = 0;

    while (start <= end) {
        let mid = Math.floor((start + end) / 2);

        if (mid * mid === x) {
            return mid;
        }
        else if (mid * mid < x) {
            solution = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }

    }
    return solution;
};
```

[Ir hacia arriba](#indice)
