# 游뱂 Problema de LeetCode: M치xima Profundidad del 츼rbol Binario

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./104.MaximumDepthOfBinaryTree.md) | [Espa침ol](./104.MaximumDepthOfBinaryTree-es.md)

## Indice

- [游뱂 Problema de LeetCode: M치xima Profundidad del 츼rbol Binario](#-problema-de-leetcode-m치xima-profundidad-del-치rbol-binario)
  - [Indice](#indice)
  - [Intuici칩n](#intuici칩n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [游눠 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici칩n

La intuici칩n detr치s de la resoluci칩n de la profundidad m치xima de un 치rbol binario es utilizar la **recursi칩n** para explorar todos los caminos posibles desde la ra칤z a los nodos hoja. La profundidad del 치rbol es esencialmente el camino m치s largo desde la ra칤z a cualquier nodo hoja.

## Enfoque

He implementado un enfoque recursivo de primero en profundidad:

1. Caso base: Si el nodo actual es `null`, devuelve 0 (ya que un 치rbol vac칤o tiene una profundidad de 0)
2. Calcular recursivamente la profundidad del sub치rbol de la izquierda
3. Calcular recursivamente la profundidad del sub치rbol derecho
4. Devuelve 1 (contando el nodo actual) m치s el m치ximo de las profundidades izquierda y derecha

Este m칠todo explora efectivamente todos los caminos del 치rbol y devuelve el m치s largo.

## Complejidad

- **Complejidad temporal: O(n)**

Cada nodo del 치rbol se visita exactamente una vez, siendo n el n칰mero de nodos del 치rbol

- Complejidad espacial: O(h)** donde h es la altura del 치rbol

    - En el peor de los casos (치rbol completamente desequilibrado), podr칤a ser O(n)
    - En el mejor de los casos (치rbol completamente equilibrado), ser칤a O(log n), ya que atravesamos la mitad del 치rbol.
    - El espacio es utilizado por la pila de recursi칩n durante el recorrido.

[Volver Arriba](#indice)

## 游눠 Soluciones

- **[Descripci칩n LeetCode](https://leetcode.com/problems/maximum-depth-of-binary-tree/)**
- **[Soluci칩n Leetcode](https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/6683282/100-runtime-by-danielpaez-dev-cq7k/)**

### JavaScript

- **[Soluci칩n GitHub](../solutions/JavaScript/104.MaximumDepthOfBinaryTree.js)**

```javascript
var maxDepth = function (root) {
    if (root === null) {
        return 0;
    }

    const left_depth = maxDepth(root.left)
    const right_depth = maxDepth(root.right)
    return 1 + Math.max(left_depth, right_depth)
};
```

### Python

- **[Soluci칩n GitHub](../solutions/Python/104.MaximumDepthOfBinaryTree.py)**

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0

        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return 1 + max(left_depth, right_depth)
```

### TypeScript

- **[Soluci칩n GitHub](../solutions/TypeScript/104.MaximumDepthOfBinaryTree.ts)**

```typescript
function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    const left_depth = maxDepth(root.left)
    const right_depth = maxDepth(root.right)
    return 1 + Math.max(left_depth, right_depth)
};
```

[Volver Arriba](#indice)
