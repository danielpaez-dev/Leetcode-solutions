#  Problema de LeetCode: Romano a Entero

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./27.RemoveElement.md) | [Espa帽ol](./27.RemoveElement-es.md)

## Indice

- [ Problema de LeetCode: Romano a Entero](#-problema-de-leetcode-romano-a-entero)
  - [Indice](#indice)
  - [Intuici贸n](#intuici贸n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [ Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici贸n

La idea principal es utilizar un puntero para reubicar los elementos que **no** sean iguales a `val`. En lugar de eliminar elementos (lo que puede ser costoso en t茅rminos de operaciones), se sobreescriben los elementos no deseados. De esta forma, los elementos v谩lidos se agrupan al principio del array y el valor del puntero nos indica cu谩ntos elementos v谩lidos tenemos.

## Enfoque

1. **Inicializar un puntero**:
Se utiliza una variable `index` iniciada en 0. Este puntero indica la posici贸n en la que se debe colocar el siguiente elemento que no es `val`.

2. **Recorrer el array**:
Se itera sobre cada elemento del array:

   * Si el elemento actual es **diferente** de `val`, se asigna a la posici贸n `nums[index]` y se incrementa `index`.
   * Si el elemento es igual a `val`, se ignora.

3. **Resultado final**:
Al finalizar el recorrido, las primeras `index` posiciones del array contienen los elementos que no son `val`. Se retorna `index` como la cantidad de elementos v谩lidos (el nuevo tama帽o del array).

## Complejidad

- **Complejidad temporal**:
El algoritmo recorre la cadena una sola vez, realizando operaciones de tiempo constante para cada car谩cter. Por lo tanto, la complejidad temporal es **O(n)**, donde n es la longitud de la cadena.

- **Complejidad espacial**:
La soluci贸n no utiliza espacio adicional aparte de algunas variables enteras, lo que hace que la complejidad espacial sea **O(1)**.

##  Soluciones

- **[Descripci贸n LeetCode](https://leetcode.com/problems/remove-element/description/)**
- **[Soluci贸n Leetcode](https://leetcode.com/problems/remove-element/solutions/6536072/two-pointers-solution-by-danielpaez-dev-kyb5/)**

### JavaScript

- **[Soluci贸n GitHub](../solutions/JavaScript/27.RemoveElement.js)**

```javascript
var removeElement = function(nums, val) {
    let index = 0;

    for(let i = 0; i < nums.length; i++){
        if(nums[i] !== val){
            nums[index] = nums[i];
            index++;
        }
    }

    return index;
};
```

### Python

- **[Soluci贸n GitHub](../solutions/Python/27.RemoveElement.py)**

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        index = 0

        for i in range(len(nums)):
            if nums[i] != val:
                nums[index] = nums[i]
                index += 1

        return index
```

### TypeScript

- **[Soluci贸n GitHub](../solutions/TypeScript/27.RemoveElement.ts)**

```typescript
function removeElement(nums: number[], val: number): number {
  let index: number = 0;

  for (let i: number = 0; i < nums.length; i++) {
    if (nums[i] !== val) {
      nums[index] = nums[i];
      index++;
    }
  }

  return index;
}

[Volver arriba](#indice)
