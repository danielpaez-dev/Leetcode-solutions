# 游뱂 Problema de LeetCode: Combinar Cadenas Alternativamente

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./1768.MergeStringsAlternately.md) | [Espa침ol](./1768.MergeStringsAlternately-es.md)

## Indice

- [游뱂 Problema de LeetCode: Combinar Cadenas Alternativamente](#-problema-de-leetcode-combinar-cadenas-alternativamente)
  - [Indice](#indice)
  - [Intuici칩n](#intuici칩n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [游눠 Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici칩n

Cuando fusionamos dos cadenas alternativamente, necesitamos intercalar caracteres de ambas cadenas. El reto es manejar el caso cuando una cadena es m치s larga que la otra. Mi primera idea fue iterar a trav칠s de ambas cadenas simult치neamente y a침adir caracteres de cada cadena de forma alterna, continuando con los caracteres restantes de la cadena m치s larga una vez que la cadena m치s corta se agota.

## Enfoque

1. Inicializar una cadena de resultados vac칤a y una variable contador i que comienza en 0
2. Determinar la longitud de cada cadena de entrada
3. Utilizar un 칰nico bucle que contin칰e hasta que hayamos procesado todos los caracteres de ambas cadenas (hasta llegar al final de la cadena m치s larga)
4. En cada iteraci칩n:

    - Si `i` est치 dentro de los l칤mites de `word1`, a침ade el car치cter en la posici칩n `i` de `word1`.
    - Si `i` est치 dentro de los l칤mites de `word2`, a침ade el car치cter en la posici칩n `i` de `word2`.
    - Incrementa `i`.

5. Devuelve la cadena combinada resultante

Esta aproximaci칩n maneja longitudes de cadena desiguales de forma elegante comprobando si el 칤ndice actual es v치lido para cada cadena antes de a침adir su car치cter.

## Complejidad

- **Complejidad temporal: O(n):**
Donde n es la longitud de la cadena m치s larga. Iteramos una vez por ambas cadenas en una sola pasada.

- **Complejidad espacial: O(n):**
Donde n es la longitud combinada de ambas cadenas. La cadena resultante contendr치 todos los caracteres de ambas cadenas de entrada.

[Ir hacia arriba](#indice)

## 游눠 Soluciones

- **[Descripci칩n LeetCode](https://leetcode.com/problems/merge-strings-alternately/description/?envType=study-plan-v2&envId=leetcode-75)**
- **[Soluci칩n Leetcode](https://leetcode.com/problems/merge-strings-alternately/solutions/6599334/easy-solution-python-js-ts/?envType=study-plan-v2&envId=leetcode-75)**

### JavaScript

- **[Soluciones GitHub](../solutions/JavaScript/1768.MergeStringsAlternately.js)**

```javascript
var mergeAlternately = function(word1, word2) {
    let res = "";
    let i = 0;
    const word1Length = word1.length;
    const word2Length = word2.length;

    while (i < Math.max(word1Length, word2Length)){
        if (i < word1Length) res += word1[i]
        if (i < word2Length) res += word2[i]
        i++;
    }

    return res;
};
```

### Python

- **[Soluci칩n GitHub](../solutions/Python/1768.MergeStringsAlternately.py)**

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        res: string = ""
        i: int = 0
        lenWord1: int = len(word1)
        lenWord2: int = len(word2)

        while (i < lenWord1 or i < lenWord2):
            if i < lenWord1:
                res += word1[i]
            if i < lenWord2:
                res += word2[i]
            i += 1

        return res

```

### TypeScript

- **[Soluci칩n GitHub](../solutions/TypeScript/1768.MergeStringsAlternately.ts)**

```typescript
function mergeAlternately(word1: string, word2: string): string {
    let res: string = "";
    let i: number = 0;
    const word1Length: number = word1.length;
    const word2Length: number = word2.length;

    while (i < Math.max(word1Length, word2Length)) {
        if (i < word1Length) res += word1[i]
        if (i < word2Length) res += word2[i]
        i++;
    }

    return res;
}
```

[Ir hacia arriba](#indice)
