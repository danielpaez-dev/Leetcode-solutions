# ü§î Problema de LeetCode: Koko Comiendo Bananas

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./875.KokoEatingBananas.md) | [Espa√±ol](./875.KokoEatingBananas-es.md)

## Indice

- [ü§î Problema de LeetCode: Koko Comiendo Bananas](#-problema-de-leetcode-koko-comiendo-bananas)
  - [Indice](#indice)
  - [Intuici√≥n](#intuici√≥n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [üí° Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici√≥n

El problema pregunta por la velocidad m√≠nima para comer (`k`) que permite a Koko comerse todos los pl√°tanos en h horas. Dado que necesitamos minimizar k mientras cumplimos con la restricci√≥n de tiempo, un enfoque de b√∫squeda binaria es apropiado. La idea clave es que la relaci√≥n entre la velocidad y el tiempo total es mon√≥tona: a medida que aumenta la velocidad, disminuye el tiempo, lo que crea un espacio de b√∫squeda adecuado para la b√∫squeda binaria.
Podemos obtener las horas totales dividiendo cada pila por `k`.

## Enfoque

1. Definir el espacio de b√∫squeda para la velocidad k de alimentaci√≥n:

    - Velocidad m√≠nima (l√≠mite izquierdo) = 1 pl√°tano por hora
    - Velocidad m√°xima (l√≠mite derecho) = tama√±o m√°ximo del mont√≥n (ya que comer m√°s r√°pido que el mont√≥n m√°s grande no proporciona ning√∫n beneficio adicional).

2. Realice una b√∫squeda binaria en este intervalo de velocidades:

    - Para cada velocidad de punto medio, calcule el total de horas necesarias para comer todos los montones
    - Si el total de horas ‚â§ h (nuestra restricci√≥n), esta velocidad funciona, as√≠ que intentamos encontrar una velocidad menor
    - Si el total de horas > h, esta velocidad es demasiado lenta, as√≠ que tenemos que buscar velocidades m√°s altas

3. Al calcular las horas para una velocidad k dada:

    - Para cada pila, necesitamos ‚åàpila/k‚åâ horas (divisi√≥n de techos)
    - Una implementaci√≥n concisa de la divisi√≥n del techo es (pila + k - 1) / k

4. La b√∫squeda binaria contin√∫a hasta que encontremos la velocidad m√≠nima viable.

## Complejidad

- **Complejidad temporal: O(n log m)**
Donde n es el n√∫mero de pilas y m es el tama√±o m√°ximo de pila. La b√∫squeda binaria requiere O(log m) iteraciones, y cada iteraci√≥n requiere O(n) tiempo para calcular las horas totales.

- **Complejidad espacial: O(1)**
Ya que s√≥lo utilizamos una cantidad constante de espacio adicional independientemente del tama√±o de la entrada.

[Volver Arriba](#indice)

## üí° Soluciones

- **[Descripci√≥n LeetCode](https://leetcode.com/problems/koko-eating-bananas/description/)**
- **[Soluci√≥n Leetcode](https://leetcode.com/problems/koko-eating-bananas/solutions/6629925/best-memory-solution-python-ts-js-by-dan-7p1y/)**

### JavaScript

- **[Soluci√≥n GitHub](../solutions/JavaScript/875.KokoEatingBananas.js)**

```javascript
var minEatingSpeed = function (piles, h) {
    let left = 1;
    let right = Math.max(...piles);

    while (left < right) {
        let mid = Math.floor((left + right) / 2);

        let total = 0
        for (const pile of piles) {
            total += Math.floor((pile + mid - 1) / mid);
        }

        if (total <= h) {
            right = mid
        } else {
            left = mid + 1
        }
    }

    return left
};
```

### Python

- **[Soluci√≥n GitHub](../solutions/Python/875.KokoEatingBananas.py)**

```python
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        left, right = 1, max(piles)

        while left < right:
            mid = (left + right) // 2
            total = sum((pile + mid - 1) // mid for pile in piles)

            if total <= h:
                right = mid
            else:
                left = mid + 1

        return left

```

### TypeScript

- **[Soluci√≥n GitHub](../solutions/TypeScript/875.KokoEatingBananas.ts)**

```typescript
function minEatingSpeed(piles: number[], h: number): number {
    let left: number = 1;
    let right: number = Math.max(...piles);

    while (left < right) {
        let mid: number = Math.floor((left + right) / 2);

        let total: number = 0
        for (const pile of piles) {
            total += Math.floor((pile + mid - 1) / mid);
        }

        if (total <= h) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
};
```

[Volver Arriba](#indice)
