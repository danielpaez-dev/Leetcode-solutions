# ü§î Problema de Leetcode: Sqrt(x)

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Ir atr√°s](../README.md)

[English](./69.Sqrt(x).md) | [Espa√±ol](./69.Sqrt(x)-es.md)

## Indice

- [ü§î Problema de Leetcode: Sqrt(x)](#-problema-de-leetcode-sqrtx)
  - [Indice](#indice)
  - [Intuici√≥n](#intuici√≥n)
- [Aproximaci√≥n](#aproximaci√≥n)
- [Complejidad](#complejidad)
  - [üí° Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## Intuici√≥n

El problema requiere que calculemos la ra√≠z cuadrada entera de un n√∫mero entero no negativo dado x. En lugar de utilizar funciones integradas como `Math.sqrt()`, nuestro objetivo es implementar un enfoque eficiente que encuentre el mayor n√∫mero entero `y` tal que `y¬≤ ‚â§ x`.

Una aproximaci√≥n de **fuerza bruta** ser√≠a iterar de 1 a x, buscando el mayor valor posible de y, pero esto es ineficiente. En su lugar, podemos utilizar la **b√∫squeda binaria**, que reduce significativamente el n√∫mero de iteraciones.

# Aproximaci√≥n

**Desglose paso a paso**:
Tratar primero los valores peque√±os:

- Si x es 0 √≥ 1, devuelve x inmediatamente ya que la ra√≠z cuadrada de estos n√∫meros son ellos mismos.

- Configurar la b√∫squeda binaria:

    S√≥lo tenemos que comprobar los n√∫meros entre 1 y x / 2 (ya que cualquier cosa mayor que x / 2 al cuadrado ser√° demasiado grande).
    Comience con inicio = 1 y final = x / 2, a continuaci√≥n, ajustar repetidamente el rango utilizando la b√∫squeda binaria.

    L√≥gica de b√∫squeda binaria:
    Encontrar el valor medio mid = (start + end) / 2.

    - Si mid¬≤ es exactamente x, hemos encontrado nuestra respuesta.
    - Si mid¬≤ es menor que x, guardamos mid como posible respuesta y movemos start a mid + 1.
    - Si mid¬≤ es mayor que x, mueve end a mid - 1.

    **Devuelve la mejor respuesta posible**:

    Dado que el bucle se detiene una vez que inicio > fin, la √∫ltima respuesta v√°lida antes de superar x se almacena en la soluci√≥n, por lo que la devolvemos.
    Este m√©todo es muy eficaz porque cada paso reduce el rango de b√∫squeda a la mitad, por lo que es mucho m√°s r√°pido que una soluci√≥n de fuerza bruta.

# Complejidad

- **Complejidad temporal**:
**La b√∫squeda binaria** permite disminuir la complejidad temporal de O(n) con b√∫squeda lineal a **O(log(n))**.

- **Complejidad espacial**:
La complejidad espacial es **O(1)** ya que s√≥lo hay variables.

[Ir hacia arriba](#indice)

## üí° Soluciones

- **[Descripci√≥n LeetCode](https://leetcode.com/problems/sqrtx/description/)**
- **[Soluci√≥n Leetcode](https://leetcode.com/problems/sqrtx/solutions/6539298/solution-by-danielpaez-dev-tl9e/)**

### JavaScript

- **[Soluci√≥n GitHub](../solutions/JavaScript/69.Sqrt(x).js)**

```javascript
var mySqrt = function (x) {
    if (x < 2) return x;

    let start = 1;
    let end = Math.floor(x / 2);
    let solution = 0;

    while (start <= end) {
        let mid = Math.floor((start + end) / 2);

        if (mid * mid === x) {
            return mid;
        }
        else if (mid * mid < x) {
            solution = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }

    }
    return solution;
};
```

### Python

- **[Soluci√≥n GitHub](../solutions/Python/69.Sqrt(x).py)**

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x

        start = 1
        end = math.floor(x // 2)
        solution = 0

        while start <= end:
            mid = (start + end) // 2

            if mid * mid == x:
                return mid

            elif mid * mid < x:
                solution = mid
                start = mid + 1
            else:
                end = mid - 1

        return solution
```

### TypeScript

- **[Soluci√≥n GitHub](../solutions/TypeScript/69.Sqrt(x).ts)**

```typescript
function mySqrt(x: number): number {
    if (x < 2) return x;

    let start: number = 1;
    let end: number = Math.floor(x / 2);
    let solution: number = 0;

    while (start <= end) {
        let mid = Math.floor((start + end) / 2);

        if (mid * mid === x) {
            return mid;
        }
        else if (mid * mid < x) {
            solution = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }

    }
    return solution;
};
```

[Ir hacia arriba](#indice)
