# ðŸ¤” Problema de LeetCode: Pares Exitosos De Hechizos y Pociones

![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&logoColor=black)
![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white)

[Volver](../README.md)

[English](./2300.SuccessfulPairsOfSpellsAndPotions.md) | [EspaÃ±ol](./2300.SuccessfulPairsOfSpellsAndPotions-es.md)

## Indice

- [ðŸ¤” Problema de LeetCode: Pares Exitosos De Hechizos y Pociones](#-problema-de-leetcode-pares-exitosos-de-hechizos-y-pociones)
  - [Indice](#indice)
  - [IntuiciÃ³n](#intuiciÃ³n)
  - [Enfoque](#enfoque)
  - [Complejidad](#complejidad)
  - [ðŸ’¡ Soluciones](#-soluciones)
    - [JavaScript](#javascript)
    - [Python](#python)
    - [TypeScript](#typescript)

## IntuiciÃ³n

Las intuiciones clave para resolver este problema son:

- Ordenar la matriz de pociones para permitir la bÃºsqueda binaria
- Para cada hechizo, calcula la fuerza mÃ­nima de pociÃ³n requerida para crear un par con Ã©xito
- Usar la bÃºsqueda binaria para encontrar eficientemente el nÃºmero de pociones exitosas para cada hechizo.

## Enfoque

1. Ordenar el array de pociones en orden ascendente
2. Para cada hechizo:

    - Calcular la fuerza mÃ­nima de pociÃ³n necesaria para crear un par exitoso
    - Utiliza la bÃºsqueda binaria para encontrar la primera pociÃ³n que cumpla o supere este umbral
    - Cuenta el nÃºmero de pociones desde ese punto hasta el final del array

3. Devuelve una matriz con el nÃºmero de parejas con Ã©xito para cada hechizo

La parte mÃ¡s complicada aquÃ­ es conseguir:

$$\text{required\\_potion} = \frac{\text{success} + \text{spell} - 1}{text{spell}} \quad \text{(divisiÃ³n entera)}$$

Esto funciona porque en lugar de calcular los productos para todas las pociones (realmente lento):

$$\text{spell} \times \text{potion} \geq \text{Ã©xito}$$

Lo transformamos en:

$$\text{potion} \geq \frac{\text{success}}{\text{spell}}$$

Calculando asÃ­:

  $$\text{required\_potion} = \frac{\text{success}} {\text{spell}}right\rceil = \frac{\text{success}} + \text{spell} - 1}{text{spell}} \quad \text{(divisiÃ³n entera)}$$

Acabo de llegar aquÃ­ por los Ãºltimos testcases que fallaban haciendo el producto de los arrays asÃ­ que he buscado soluciones y he visto que este producto es la parte menos optimizada del cÃ³digo que tenÃ­a.

AdemÃ¡s, en JavaScript y TypeScript, debemos tener en cuenta que no podemos ordenar las pociones de los arrays como en Python porque la funciÃ³n sort ordena cadenas por lo que ordenarÃ¡ el array de forma inesperada. AsÃ­ que tenemos que ordenarlo de la siguiente manera:
`potions.sort((a, b) => a - b);`
Esto funciona porque compara valores y ordena el array asÃ­:

- Devuelve un nÃºmero negativo si a debe ir antes que b
- Devuelve un nÃºmero positivo si a deberÃ­a venir despuÃ©s de b
- Devuelve 0 si son iguales

## Complejidad

- **Complejidad temporal: O(m log n + n log m)**

  - m = longitud de la matriz de hechizos
  - n = longitud de la matriz de pociones
  - Ordenar pociones requiere O(n log n)
  - La bÃºsqueda binaria de cada hechizo requiere O(log n)
  - La complejidad temporal total es O(m log n)

- **Complejidad espacial: O(1) espacio extra (excluyendo el array de salida)**

  - Estamos modificando la matriz de entrada en el lugar
  - SÃ³lo se utiliza una cantidad constante de espacio adicional para los cÃ¡lculos

[Ir hacia arriba](#indice)

## ðŸ’¡ Soluciones

- **[DescripciÃ³n LeetCode](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/)**
- **[SoluciÃ³n Leetcode](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/6585828/python-solution-division-no-libraries/)**

### JavaScript

- **[SoluciÃ³n GitHub](../solutions/JavaScript/2300.SuccessfulPairsOfSpellsAndPotions.js)**

```javascript
var successfulPairs = function(spells, potions, success) {
    potions.sort((a, b) => a - b);
    const n = potions.length;
    const result = [];

    for (const spell of spells) {
        const requiredPotion = Math.floor((success + spell - 1) / spell);

        let left = 0;
        let right = n;
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (potions[mid] >= requiredPotion) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        const count = n - left;
        result.push(count);
    }

    return result;
};
```

### Python

- **[SoluciÃ³n GitHub](../solutions/Python/2300.SuccessfulPairsOfSpellsAndPotions.py)**

```python
from typing import List

class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        n = len(potions)
        result = []

        for spell in spells:
            required_potion = (success + spell - 1) // spell

            left = 0
            right = len(potions)
            while left < right:
                mid = (left + right) // 2
                if potions[mid] >= required_potion:
                    right = mid
                else:
                    left = mid + 1

            count = n - left
            result.append(count)

        return result
```

### TypeScript

- **[SoluciÃ³n GitHub](../solutions/TypeScript/2300.SuccessfulPairsOfSpellsAndPotions.ts)**

```typescript
function successfulPairs(spells: number[], potions: number[], success: number): number[] {
    potions.sort((a, b) => a - b);
    const n: number = potions.length;
    let result: number[] = [];
    let left: number;
    let right: number;

    for (const spell of spells) {
        const requiredPosition: number = Math.ceil(success / spell);
        left = 0;
        right = n;
        while (left < right) {
            let mid: number = Math.floor((left + right) / 2);
            if (potions[mid] >= requiredPosition){
                right = mid
            } else {
                left = mid + 1;
            }
        }
        let count: number = n - left;
        result.push(count);
    }
    return result;
};
```

[Ir hacia arriba](#indice)
